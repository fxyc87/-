##注意：本项目来源于 https://www.amobbs.com/thread-5768213-1-1.html

##这里不是原作者的GIT 这里似乎是smset的仓库 https://github.com/smset028/xxddq

最新版本：1.2.3，支持两种方式（Switch和SetJmp），支持8/16/32位单片机


小小调度器是一种轻量级的、高效的、可移植的C语言调度器。它由作者“smset”开发，并且被“Gthgth”整理说明。小小调度器特别适合在资源受限的嵌入式系统中使用，如51单片机等，但其设计的通用性确保了几乎可以在任何支持C语言的CPU上移植和使用。

调度器的主要特点包括超级的移植性、小巧的代码体积、对RAM和ROM资源的极致节约、简化而强大的任务管理机制以及基于定时器触发的高效调度策略。

小小调度器任务函数编写时，建议使用静态局部变量以避免不必要的RAM消耗，并且要求任务函数内部不得使用switch语句和return语句。这些限制并没有明显增加编程的难度，反而有助于提高代码的清晰度和可维护性。

使用小小调度器所涉及的成本包括硬件资源成本、学习成本、移植成本、效率成本、商业成本以及稳定性成本。这些成本相比使用其他操作系统或调度系统来说都非常低。硬件资源消耗极小，例如在keil环境下，内存（RAM）消耗只有22字节，程序存储空间（ROM）消耗为126字节。学习成本低，因为调度器代码量小且逻辑简单。移植成本几乎可以忽略不计，因为它的设计允许在多种CPU架构间轻松迁移。效率成本低，因为调度器设计得非常高效，任务切换时间可以达到微秒甚至亚微秒级别。商业成本为零，因为调度器是开源且免费的。稳定性成本也较低，因为调度器设计简单，没有复杂的机制，易于理解和控制。

小小调度器的原理基于ProtoThread模型，实现了一种协作式多任务机制。该模型中，任务通过WaitX宏主动让出CPU，让出时记录当前的断点位置和任务的等待状态。RunTask宏则负责定时服务，当任务的延时时间到达时，调度器会调用RunTask宏来运行相应的任务函数。

调度器的核心在于延时查询机制，通过不断查询任务的延时时间，并对那些延时已到的任务执行后续代码。从这一机制来看，小小调度器也可以被称为“通用C延时查询调度器”。在实际使用中，它允许开发者以非常简单的方式实现多任务处理。

通过学习和应用小小调度器，开发者能够以最小的成本和资源投入，实现对任务的有效管理和调度。这在资源紧张、对性能有较高要求的嵌入式应用领域尤其具有价值。
